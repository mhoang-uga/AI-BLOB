import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;

import javax.swing.JTextArea;
import javax.swing.border.TitledBorder;
import javax.swing.JComboBox;

/**
 * S e t u p W i n d o w
 *
 * <p>View for the setup window. Defines the parameter of the gam then launch
 * the game.
 * 
 * @author Eric Pietroupo
 * ( ericp@lariennalibrary.com )
 *
 * @version march 26th, 2017
 * ( GNU General Public License )
 *
 *  <p> This class's layout use nested BorderLayout. More annoying to build up
 *  but it still gives interesting results.</p?
 */


public class SetupWindow extends JFrame
{
   /** Width of the window */
   public static final int WIN_WIDTH = 450;
   /** Height of the window */
   public static final int WIN_HEIGHT = 525;
   /** Pixel width of the layout board */
   public static final int BOARD_WIDTH = 204;
   /** Pixel width of a single board space */
   public static final int SPACE_WIDTH = (BOARD_WIDTH - 1) / 7;
   
   /** ID Generated by Eclipse */
   private static final long serialVersionUID = -851074011258661482L;
   /** Panel that hold the bottom part of the window*/
   private JPanel p_pan_main = new JPanel();
   /** Panel that holds the board layout widgets*/
   private JPanel p_pan_left = new JPanel();
   /** Panel that holds the various configuration and start button*/
   private JPanel p_pan_right = new JPanel();
   /** Panel to surround a button group for the rules */
   private JPanel p_pan_rules = new JPanel();
   /** Panel to surround a button group for the players */
   private JPanel p_pan_players = new JPanel();
   /** Panel for the number of moves */
   private JPanel p_pan_nbmoves = new JPanel();
   
   /** Contains the description and rules of the game */
   private JTextArea p_txa_description = new JTextArea (
           "Implemented by Eric Pietrocupo (2017) licensed under the GNU GPL"
         + "\n--- Rules ---"
         + "\nThe goal of the game is to expand and convert your opponent's pieces"      
         + " by duplicating or moving your pieces 2 space away to a location"
         + " adjacent to your opponent in order to convert his pieces."
         + " When a player cannot make any move, the game ends."
         + "\n\n--- Play syntax ---"
         + "\nAdding a piece can be done using a letter and a digit like 'd3' or '3d'"
         + " while movement requires a pair of coordinates, source first then destination. "
         + "\nFor Example: 'd3 c5'"
         );
   
  
   /** Used to select the type of layout desired for playing */
   private JComboBox<Board.Layout> p_cmb_layout = new JComboBox<Board.Layout> ();
   /** A custom made widget to draw the layout of the board manually inside
    * a panel. */
   private JPanel p_pan_layout; //custom made widget
   
   /** Rule radio button */
   private JRadioButton p_rad_nojump = new JRadioButton ("Virus (no jumps)");
   /** Rule radio button */
   private JRadioButton p_rad_withjump = new JRadioButton ("Ataxx (with jumps)");
   /** Button group for the rules */
   private ButtonGroup p_grp_rules = new ButtonGroup();
   
   /** Players radio button */
   private JRadioButton p_rad_1player = new JRadioButton ("1 Player vs AI");
   /** Players radio button */
   private JRadioButton p_rad_2player = new JRadioButton ("2 players");
   /** Button group for the players*/
   private ButtonGroup p_grp_players = new ButtonGroup();
   
   /** Number of moves ahead label*/
   private JLabel p_lbl_nbmoves = new JLabel ("Nb moves ahead");
   /** Number of moves ahead combo*/
   private JComboBox<String> p_cmb_nbmoves = new JComboBox<String> ();   
   
   
   /** Start button to start the game and close this window */
   private JButton p_btn_start = new JButton ("Start Game");
   
   

   /**
    * Create the frame.
    */
   public SetupWindow()
   {
      // Configuring Widgets
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      
      Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();
      setBounds( (screen_size.width / 2) - ( WIN_WIDTH / 2), 
            (screen_size.height / 2) - (WIN_HEIGHT / 2), WIN_WIDTH, WIN_HEIGHT);
      
      setLayout ( new BorderLayout( 5, 5 ) );
      setTitle ( "Ataxx/Virus Game Setup");
      
      p_txa_description.setEditable(false);
      p_txa_description.setWrapStyleWord(true);
      p_txa_description.setLineWrap(true);
      p_txa_description.setMaximumSize(new Dimension (WIN_WIDTH, WIN_HEIGHT ));
      
      p_pan_left.setBorder ( new TitledBorder ("Board Layout"));
      p_pan_left.setLayout ( new BorderLayout( 5, 5 ) );      
      p_pan_right.setLayout( new GridLayout (4, 1));
      
      p_pan_rules.setBorder(new TitledBorder ("Game Rules"));
      p_pan_rules.setLayout ( new BorderLayout ());
      
      p_pan_players.setBorder( new TitledBorder ("Players"));
      p_pan_players.setLayout ( new BorderLayout());
      
      p_pan_nbmoves.setBorder( new TitledBorder ("AI Thinking"));
      p_pan_nbmoves.setLayout ( new BorderLayout());
      
      p_grp_rules.add ( p_rad_nojump );
      p_grp_rules.add ( p_rad_withjump );
      p_rad_nojump.setSelected(true);
      
      p_grp_players.add ( p_rad_1player );
      p_grp_players.add ( p_rad_2player );
      p_rad_1player.setSelected(true);
      
      p_cmb_nbmoves.addItem("1 : Do not think ahead");
      p_cmb_nbmoves.addItem("2 : very fast");
      p_cmb_nbmoves.addItem("3 : good for ataxx");
      p_cmb_nbmoves.addItem("4 : slow for ataxx");
      p_cmb_nbmoves.addItem("5 : good for virus");
      p_cmb_nbmoves.addItem("6 : slow for virus");
      p_cmb_nbmoves.addItem("7 : very slow");
      p_cmb_nbmoves.addItem("8 : Extremely slow ");
      p_cmb_nbmoves.setSelectedIndex( 3 );
      
      for ( Board.Layout type: Board.Layout.values())
      {
         p_cmb_layout.addItem(type);
      }
      
      
      // Custom Widget for the board layout
      // What it does to redefine the paint method to draw inside the graphic
      // object the layout of the board. Then redefine the min/max/preferred
      // size methods which are going to be called by the Layout manager
      // to make sure the panel does not change in size.
      
      p_pan_layout = new JPanel () {

         /** ID Generated by Eclipse */
         private static final long serialVersionUID = -1142669755142263190L;
      
         @Override
         public void paint ( Graphics picture ) 
         {
            super.paint(picture);
            Board.Layout layout = (Board.Layout ) p_cmb_layout.getSelectedItem();
            draw_board ( picture , layout.get_board() );
            
         }
         
         // set min and max size as the same value to make sure the layout 
         // manager always use the same value
         @Override
         public Dimension getPreferredSize () 
         {
            return new Dimension ( BOARD_WIDTH, BOARD_WIDTH );
         }
         
         @Override
         public Dimension getMinimumSize () 
         {
            return new Dimension ( BOARD_WIDTH, BOARD_WIDTH );
         }
         
         @Override
         public Dimension getMaximumSize () 
         {
            return new Dimension ( BOARD_WIDTH, BOARD_WIDTH );
         }
         
      };
      p_pan_layout.setBackground ( Color.WHITE );
      
      // Adding Listeners
      
      p_cmb_layout.addActionListener(new ActionListener () 
      {
         @Override
         public void actionPerformed(ActionEvent arg0)
         {
            p_pan_layout.repaint();            
         }         
      });
      
      p_btn_start.addActionListener(new ActionListener ()
      {

         @Override
         public void actionPerformed(ActionEvent e)
         {
            event_start_game();            
         }
         
      });
      
      // Adding Widgets to the panels
      // It is using nested Border Layout split as top/center or left/center
      
      p_pan_left.add ( p_cmb_layout, BorderLayout.NORTH );
      p_pan_left.add ( p_pan_layout, BorderLayout.SOUTH );
      p_pan_rules.add ( p_rad_nojump, BorderLayout.NORTH );
      p_pan_rules.add ( p_rad_withjump, BorderLayout.CENTER );
      p_pan_players.add( p_rad_1player, BorderLayout.NORTH );
      p_pan_players.add( p_rad_2player, BorderLayout.CENTER );
      p_pan_nbmoves.add ( p_lbl_nbmoves, BorderLayout.NORTH );
      p_pan_nbmoves.add ( p_cmb_nbmoves, BorderLayout.CENTER );
      
      
      p_pan_right.add ( p_pan_rules);
      p_pan_right.add( p_pan_players );
      p_pan_right.add ( p_pan_nbmoves );
      p_pan_right.add ( p_btn_start );
      
      p_pan_main.add ( p_pan_left, BorderLayout.WEST );
      p_pan_main.add ( p_pan_right, BorderLayout.CENTER );
      
      
      add (p_txa_description, BorderLayout.NORTH );
      add ( p_pan_main, BorderLayout.CENTER );
      
      setVisible ( true );
   }
   
   // Private Methods
   
   /**
    * Method used by the custom widget to draw inside the panel the a preview
    * of the layout of the board.
    * 
    * @param picture graphic object to use for drawing
    * @param board content of the board.
    */
   private void draw_board ( Graphics picture, char [][] board )
   {
      picture.setColor(Color.BLACK);
      
      for ( int j = 0 ; j < board.length; j++) 
      {
         for (int  i = 0 ; i < board[j].length; i++)
         {
            // Drawing the board
            switch ( board [ j ] [ i ])
            {
            case Board.BLACK:
            case Board.WHITE:
            case Board.PLAYABLE:
               picture.drawRect(i * SPACE_WIDTH, j * SPACE_WIDTH, SPACE_WIDTH, SPACE_WIDTH);
            break;
            case Board.NONPLAYABLE:
               picture.fillRect(i * SPACE_WIDTH, j * SPACE_WIDTH, SPACE_WIDTH, SPACE_WIDTH);
            break;
            }
            
            // Drawing the pieces over the board
            switch ( board [ j ] [ i ])
            {
            case Board.BLACK:
               picture.fillOval(( i * SPACE_WIDTH) + 2, (j * SPACE_WIDTH) + 2
                     , SPACE_WIDTH - 4, SPACE_WIDTH - 4);
            break;   
            case Board.WHITE:
               picture.drawOval(( i * SPACE_WIDTH) + 2, (j * SPACE_WIDTH) + 2
                     , SPACE_WIDTH - 4, SPACE_WIDTH - 4);
            break;   
            }
            
         }
         
      }
   }
   
   /**
    * Since this is the only event in the whole window, I did not made a separate manager class.
    * This method creates the board according to the setup and open the game window while
    * closing itself. 
    */
   
   private void event_start_game ()
   {
      Board.Layout tmplayout = ((Board.Layout) p_cmb_layout.getSelectedItem());
      
      //Instantiate and connect the board window manager and view with each other
      BoardWindow board_view = new BoardWindow();
      BoardWindowManager board_manager = new BoardWindowManager ( board_view );
      board_view.set_event_manager( board_manager );      
      
      //Build the window content
      board_view.build_interface();
      
      //Configure the manager with the selected settings in this window.
      board_manager.setup_board( tmplayout.get_board() , p_rad_withjump.isSelected() );
      board_manager.set_2players( p_rad_2player.isSelected() );
      board_manager.set_nb_moves_ahead ( p_cmb_nbmoves.getSelectedIndex() + 1);
      
  
      // hide and dispose the window since we don't need it anymore
      setVisible(false);
      dispose();
   }

}
